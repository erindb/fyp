// to run this file: webppl --require regex model0.wppl

/*

## Question

How do people generate stories from events?

## Generative Model

* Have a stochastic transition network where
some events are more probable than others

* Sample event chains from this network:
That's what happened.

* Generate stories from these chains using a
story generator

## Story generator

BasicModel:
Just comment on a subset of what happened.

DumbInformativityModel:
P(mention | happen) depends on probability of event.

InformativityModel:
P(mention | happen) depends on predictability of event given context.

## Another (future) question

If we know how people's choices of what events to mention
is biased, can we interpret their stories better?

## Related ideas...

A thought: I like to think of explanations as stories whose
conclusion is the thing you want to explain.
So understanding the kinds of informativity constraints
on what should go into a story could help understand a bit
more about how explanations work...? And vice versa?

*/

var videoGame = function() {
	// levels get progressively less easy
	var easiness = { 1: 0.8, 2: 0.5, 3: 0.2 };
	var levels = easiness.keys;

	// can change the length of the game:
	var highestLevel = 2;

	// boredome increases throughout the game.
	// could increase more for a loss?
	var increaseBoredom = function(boredom) {
		return boredom + 0.2;
	}

	var videoGameTransition = function(sequence, state) {
		if (state.type == 'stop') {
			var description = 'Anna stops playing.';
			return sequence.concat([description]);
		} else if (state.type == 'play') {
			var description = 'Anna plays level ' + state.level + '.';
			var outcome = flip(easiness[state.level]) ? 'win' : 'lose';
			return videoGameTransition(
				sequence.concat([description]),
				_.extend(state, {type: outcome, boredom: increaseBoredom(state.boredom)})
			)
		} else if (state.type == 'win') {
			if (state.level == highestLevel) {
				var description = 'Anna wins the game.';
				return videoGameTransition(
					sequence.concat([description]),
					_.extend(state, {type: 'stop'})
				)
			} else {
				var description = 'Anna wins level ' + state.level + '.';
				var nextAction = flip(state.boredom) ? 'bored' : 'play';
				// Anna progresses to next level if she wins
				var nextLevel = state.level + 1;
				return videoGameTransition(
					sequence.concat([description]),
					_.extend(state, {type: nextAction, level: nextLevel})
				)
			}
		} else if (state.type == 'lose') {
			var description = 'Anna loses level ' + state.level + '.';
			var nextAction = flip(state.boredom) ? 'bored' : 'play';
			// Anna goes to level 1 when she loses any level
			var nextLevel = 1;
			return videoGameTransition(
				sequence.concat([description]),
				_.extend(state, {type: nextAction, level: nextLevel})
			)
		} else if (state.type == 'bored') {
			var description = 'Anna gets bored.';
			return videoGameTransition(
				sequence.concat([description]),
				_.extend(state, {type: 'stop'})
			)
		}
	}
	return videoGameTransition([], {type: 'play', level: 1, boredom: 0.2});
}

var literalSequenceFinder = cache(function (subsequence, generativeModel) {
	var isSubsequence = function(sub, full) {
		var fullstr = full.join('');
		var substr = sub.join('.*');
		return regex.match(substr, fullstr) != null;
	}
	Rejection(function() {
		var fullSequence = generativeModel();
		condition( isSubsequence(subsequence, fullSequence) )
		return fullSequence;
	}, 100)
})

var lengthCost = function(story) {
	return story.length;
}
var noCost = function(story) {
	return 0;
}

var costs = {
	length: lengthCost,
	none: noCost
}

var generativeModels = {
	videoGame: videoGame
}

var storyteller = function(parameters) {
	var fullSequence = parameters.fullSequence;
	var generativeModel = parameters.generativeModel;
	var cost = parameters.cost;
	var informative = parameters.informative;

	if (informative) {
		return Rejection(function() {
			var subsequence = filter(function(sentence) {return flip(0.5);}, fullSequence);
			var interpretedSequence = sample(literalSequenceFinder(subsequence, generativeModel));
			condition( fullSequence.join('') == interpretedSequence.join('') )
			factor( - cost(subsequence) )
			return subsequence;
		}, 100)
	} else {
		return Rejection(function() {
			// any subsequence of the original sequence is acceptable.
			var subsequence = filter(function(sentence) {return flip(0.5);}, fullSequence);
			// literalStoryteller doesn't need to be understood
			factor( - cost(subsequence) )
			return subsequence;
		}, 100)
	}
}

/*
Make a graph:
for each item in the full sequence, how likely is it to be mentioned?
what's the conditional probability of it given the other parts of the story?
what's the marginal probability of it overall?
*/

var fullSequence = [
	'Anna plays level 1.',
	'Anna loses level 1.',
	'Anna gets bored.',
	'Anna stops playing.'
]
var informativeStory = storyteller({
	fullSequence: fullSequence,
	generativeModel: generativeModels.videoGame,
	cost: costs.length,
	informative: true
})
var uninformativeShortStory = storyteller({
	fullSequence: fullSequence,
	generativeModel: generativeModels.videoGame,
	cost: costs.length,
	informative: false
})
var uninformativeStory = storyteller({
	fullSequence: fullSequence,
	generativeModel: generativeModels.videoGame,
	cost: costs.none,
	informative: false
})
var marginalizeMention = function(event, storyDistribution) {
	var marginalized = Rejection(function() {
		var story = sample(storyDistribution)
		// return true iff event is in story
		return (story.indexOf(event) > -1)
	}, 100)
	return Math.exp(marginalized.score([], true))
}
var marginalizeMentionFunction = function(event, generativeModel) {
	var marginalized = Rejection(function() {
		var story = generativeModel()
		// return true iff event is in story
		return (story.indexOf(event) > -1)
	}, 100)
	return Math.exp(marginalized.score([], true))
}
var eventStats = function(event) {
	return {
		'event': event,
		'probMentionUninformative':marginalizeMention(event, uninformativeStory),
		'probMentionInformative': marginalizeMention(event, informativeStory),
		'probMentionUninformativeShort': marginalizeMention(event, uninformativeShortStory),
		'marginalProbGivenGenerativeModel': marginalizeMentionFunction(event, generativeModels.videoGame)
	}
}
display(map(eventStats, fullSequence))

// var informativeStoryDistributionWithLengthCost = InformativeStoryteller({
// 	fullSequence: ,
// 	generativeModel: videoGame,
// 	cost: lengthCost
// });

// var informativeStoryDistributionWithNoCost = InformativeStoryteller({
// 	fullSequence: [
// 		'Anna plays level 1.',
// 		'Anna loses level 1.',
// 		'Anna gets bored.',
// 		'Anna stops playing.'
// 	],
// 	generativeModel: videoGame,
// 	cost: noCost
// });

// var uninformativeStoryDistributionWithLengthCost = UninformativeStoryTeller({
// 	fullSequence: [
// 		'Anna plays level 1.',
// 		'Anna loses level 1.',
// 		'Anna gets bored.',
// 		'Anna stops playing.'
// 	],
// 	generativeModel: videoGame,
// 	cost: lengthCost
// });

// display('uninformative with length')
// display(uninformativeStoryDistributionWithLengthCost.hist)
// display('informative with length')
// display(informativeStoryDistributionWithLengthCost)

/*
My intuition:
An informativity-based storytelling model (InformativityModel)
	* will not talk about what level Anna plays,
	* will talk about the *last* level Anna won (or lost?)
	* will mention if Anna is bored, or if she wins the game
A probability-based (DumbInformativityModel) model
	* might not mention if Anna gets bored, since that's likely to happen?
	* might be likely to mention that Anna played level 2?
*/

/*
what if stories can have discourse connectives:
but, and, so, because

when should it mention an event at all
when should it mention it *and* use a modifier
*/

/*
Make a graph of the probability of recovering a left-out event
from an informative storyteller vs. recovering a left-out event
from a random storyteller.
*/

'finished'