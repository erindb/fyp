// index.js

// in the future, it would be nice to parametrically
// manipulate the complexity/structure of the generative
// models and show how that changes the difficulty of
// recovering a left out story event (narrative cloze) or of
// recovering an unmentioned seuqnece event (what scripts
// are supposed to fascilitate)

var generativeModels = {
	videoGame: Infer(
		{
			method: 'enumerate'
		},
		function() {
			// levels get progressively less easy
			var easiness = { 1: 0.8, 2: 0.5, 3: 0.2 };
			var levels = easiness.keys;
			var maxSequenceLength = 15;

			// can change the length of the game:
			var highestLevel = 2;

			// boredome increases throughout the game.
			// could increase more for a loss?
			var increaseBoredom = function(boredom) {
				return Math.min(1, boredom + 0.2);
			}

			var videoGameTransition = function(sequence, state) {
				if (state.type == 'stop') {
					var description = 'Anna stops playing.';
					return sequence.concat([description]);
				} else if (sequence.length == maxSequenceLength) {
					var description = 'Anna stops playing.';
					return sequence.concat([description]);
				} else if (state.type == 'play') {
					var description = 'Anna plays level ' + state.level + '.';
					var outcome = flip(easiness[state.level]) ? 'win' : 'lose';
					return videoGameTransition(
						sequence.concat([description]),
						_.extend(state, {type: outcome, boredom: increaseBoredom(state.boredom)})
					)
				} else if (state.type == 'win') {
					if (state.level == highestLevel) {
						var description = 'Anna wins the game.';
						return videoGameTransition(
							sequence.concat([description]),
							_.extend(state, {type: 'stop'})
						)
					} else {
						var description = 'Anna wins level ' + state.level + '.';
						var nextAction = flip(state.boredom) ? 'bored' : 'play';
						// Anna progresses to next level if she wins
						var nextLevel = state.level + 1;
						return videoGameTransition(
							sequence.concat([description]),
							_.extend(state, {type: nextAction, level: nextLevel})
						)
					}
				} else if (state.type == 'lose') {
					var description = 'Anna loses level ' + state.level + '.';
					var nextAction = flip(state.boredom) ? 'bored' : 'play';
					// Anna goes to level 1 when she loses any level
					var nextLevel = 1;
					return videoGameTransition(
						sequence.concat([description]),
						_.extend(state, {type: nextAction, level: nextLevel})
					)
				} else if (state.type == 'bored') {
					var description = 'Anna gets bored.';
					return videoGameTransition(
						sequence.concat([description]),
						_.extend(state, {type: 'stop'})
					)
				}
			}
			return videoGameTransition([], {type: 'play', level: 1, boredom: 0.2});
		}
	),
	routeToSchool: Infer(
		{method: 'enumerate'},
		function() {
			// school is on the corner of 1st Ave. and A St.
			// home is on the corner of 3rd Ave. and B St.
			// there's a bike path from B St. to school
			// the bus stops at the corner of 1st Ave. and B St.

			var streetsNS = ['1st Ave', '2nd Ave', '3rd Ave'];
			var streetsEW = ['A St', 'B St'];

			var homeCrossStreet = { NS: '3rd Ave', EW: 'B St' };
			var schoolCrossStreet = { NS: '1st Ave', EW: 'A St'};

			var transition = function(sequence, state) {
				if (state.type == 'go inside') {
					var description = 'Anna went inside.';
					return sequence.concat([description]);
				}
				else if (state.type == 'decide') {
					var decision = uniformDraw([
						// 'take the bus', //implement this later
						'walk',
						'bike'
					]);
					var description = 'Anna decided to ' + decision +
						' to school.';
					var nextAction = decision=='bike' ? 'get bike' : 'leave home';
					return transition(
						sequence.concat([description]),
						_.extend(state, {
							type: nextAction,
							mode: decision
						})
					);
				} else if (state.type == 'get bike') {
					var description = 'Anna got out her bicycle.';
					return transition(
						sequence.concat([description]),
						_.extend(state, {
							type: 'leave home'
						})
					);
				} else if (state.type == 'leave home') {
					var description = 'Anna left home.';
					// if biking or walking, likely going down B St.,
					// but this should be handled in a factor
					// that says bike path is more likely
					// var probs = [0.5, 0.5];
					// var direction = categorical(probs, ['NS', 'EW']);
					var direction = uniformDraw(['NS', 'EW']);
					return transition(
						sequence.concat([description]),
						_.extend(state, {
							type: 'intersecion',
							NS: homeCrossStreet.NS,
							EW: homeCrossStreet.EW,
							direction: direction
						})
					);
				} else if (state.type == 'intersecion') {

					// we know what direction we're going
					var description = 'She went down ' + state[state.direction] + '.';

					var getNextTurn = function(state) {
						if (state.direction=='NS') {
							// if we're headed N/S we're going to choose an E/W street next
							// depending on how many more E/W streets are left, we turn on them
							// and start going E/W

							// if we're already as far E/W as we need to be,
							// just go to school, there are no more turns to make
							if (schoolCrossStreet.NS==state.NS) {
								return _.extend(state, {
									EW: schoolCrossStreet.EW,
									direction: 'EW'
								});
							} else {
								var currentSt = state.EW;
								var currentIndex = streetsEW.indexOf(currentSt);
								var nextIndex = randomInteger(currentIndex);
								var nextSt = streetsEW[nextIndex];
								return _.extend(state, {
									EW: nextSt,
									direction: 'EW'
								});
							}
						} else if (state.direction=='EW') {
							// if we're headed E/W,
							// choose a N/S street to turn on
							// and go in that direction
							
							// if we're already as far N/S as we need to be,
							// just go to school, there are no more turns to make
							if (schoolCrossStreet.EW==state.EW) {
								return _.extend(state, {
									NS: schoolCrossStreet.NS,
									direction: 'NS'
								});
							} else {
								var currentSt = state.NS;
								var currentIndex = streetsNS.indexOf(currentSt);
								var nextIndex = randomInteger(currentIndex);
								var nextSt = streetsNS[nextIndex];
								return _.extend(state, {
									NS: nextSt,
									direction: 'NS'
								});
							}
						}
					}

					// if we're headed E/W on B St, we
					// might take the bike path to school.
					if (state.EW=='B St' & state.direction=='EW') {
						if (flip()) {
							return transition(
								sequence.concat([description]),
								_.extend(state, {
									type: 'bike path'
								})
							);
						}
					}

					var nextTurn = getNextTurn(state);

					// we go some number of streets in that direction
					// and then go in the other direction down a new street

					// TO DO:
					// depending on model of transport,
					// transition probabilities are different
					// at any intersection,
					// one might turn or continue
					// bikes and walkers are likely to take the bike path

					// TO DO:
					// if Anna is taking the bus, she goes to the bus stop.
					// if Anna is walking or biking, she probably goes down B St. to get to the bike path

					if (nextTurn.NS==schoolCrossStreet.NS & nextTurn.EW==schoolCrossStreet.EW) {
						return transition(
							sequence.concat([description]),
							_.extend(state, {
								type: 'arrive'
							})
						);
					} else {
						return transition(
							sequence.concat([description]),
							_.extend(state, {
								type: 'intersecion',
								NS: nextTurn.NS,
								EW: nextTurn.EW,
								direction: nextTurn.direction
							})
						);
					}
				} else if (state.type == 'bike path') {
					var description = 'She took the bike path.';
					return transition(
						sequence.concat([description]),
						_.extend(state, {
							type: 'arrive'
						})
					);
				} else if (state.type == 'arrive') {
					var description = 'Anna arrived at school.'
					return transition(
						sequence.concat([description]),
						_.extend(state, {
							type: 'go inside'
						})
					);
				}
			}
			return transition([], {type: 'decide'});
		}
	)
}

"generative models loaded"